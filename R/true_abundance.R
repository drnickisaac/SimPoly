#' Create true abundances per site and year
#'
#' This function calculate true abundance in each sampling round.
#'
#' @param n_round Numeric. Number of sampling rounds. Default to 8.
#' @param startmonth Numeric. Number of month starting to sample. Default to 2.
#' @param endmonth Numeric. Number of month stopping to sample. Default to 10.
#' @param site_years A data.frame, generated by define_sites_years()
#' @param sp_responses A data.frame, generated by sp_responses()
#' @param white_noiseCV Numeric, the expected CV across years. Default to 0.5 (use values 0-1)
#'
#' @return A data.frame.
#' @export
#'
#' @examples
#' pool <- sp_pool(50)
#' site_years <- define_sites_years(pool = pool, n_years = 3, n_sites = 10)
#' pars <- sp_responses(site_years = site_years)
#' true_abundance(n_round = 8,
#'                site_years = site_years,
#'                sp_responses = pars)
true_abundance <- function(n_round = 8, startmonth = 2, endmonth = 10,
                           site_years = NA, sp_responses = NA, white_noiseCV = 0.5){
  #require(reshape2)
  #require(coenocliner)
  #Define sampling events per year:
  data <- site_years
  pars <- sp_responses
  #Rounds are constrained from February to October by default.
  rounds <- ceiling(seq(startmonth*30, endmonth*30, length = n_round)) # gradient locations (sampling points)
  #Calculate abundande per site and year
  n_years <- max(data$year)
  site_names <- unique(data$siteID)
  #mus <- list() #store in lists if needed (do we need to keep track of this?)
  #For now we store final counts only
  simnbs <- data.frame(year = NA, siteID = NA, round = NA, jday = NA, species = NA, abundance = NA)
  for(j in 1:n_years){
    #select year j
    year_temp <- subset(data, year == j)
    #We add white noise to h as a function of year (yearly fluctuations)
    #white_noise <- rnorm(length(pars$h), 0, 0.05) #this is very little white noise. It can be added to red noise below.
    sd = pars$h*white_noiseCV #mean * CV
    pars$h2 <- pars$h
    for(k in 1:length(pars$h)){
      pars$h2[k] <- rnorm(1, pars$h[k], sd[k]) #this adds white noise proportional to species abundances.
    }
    pars$h2 <- ifelse(pars$h2 < 0, 0, pars$h2)
    #plot(pars$h2, pars$h)
    #And a directional noise (red noise) based on species responses.
    pars$h_y <- pars$h2 * ((pars$slope)^j) #can never get negative, just terribly small.
    for(i in 1:length(site_names)){
      #select site i
      site_temp <- subset(data, siteID == site_names[i])
      #select species present in site i
      pars_temp <- pars[which(pars$species %in% site_temp$species),]
      pars_i <- cbind(opt = pars_temp$opt, tol = pars_temp$tol, h = pars_temp$h_y)
      #create ideal community
      #mus[[i]]  <- coenocline(locs, responseModel = "gaussian", params = pars_i,
      #  expectation = TRUE)
      #plot(mus[[i]], lty = "solid", type = "l", ylim = c(0,100), xlab = "jday", ylab = "Abundance", las= 1)
      #create observed community
      simnb <- coenocliner::coenocline(rounds, responseModel = "gaussian", params = pars_i,
                          countModel = "negbin", countParams = list(alpha = 0.5))
      #transform the sim to long format
      sim <- as.data.frame(simnb) #we lose species names
      colnames(sim) <- pars_temp$species
      sim$rounds <- 1:length(rounds)
      sim$jday <- rounds
      sim_melted <- reshape2::melt(data = sim, id.vars = c("rounds", "jday"), preserve.na = T)
      sim_melted$siteID <- site_names[i]
      sim_melted$year <- j
      sim_melted <- sim_melted[,c("rounds", "jday", "variable", "value", "siteID", "year")]
      colnames(sim_melted) <- c("round", "jday", "species", "abundance", "siteID", "year")
      simnbs <- rbind(simnbs, sim_melted[,c("year", "siteID", "round", "jday", "species", "abundance")])
    }
    simnbs <- simnbs[-1,]
    #head(simnbs)
  }
  #head(simnbs)
  #dim(simnbs) # 3y * 10 sites *30 sp *8 rounds <- ~ 7200
  simnbs
}
