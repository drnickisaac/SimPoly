#' Create n sites sampled over t years
#'
#' This function creates for a given species pool, a data.frame of species observed per site and year.
#'
#' @param pool list, a list generated by sp_pool() containing species and ditrib
#' @param n_years Numeric, number of years
#' @param n_sites Numeric, number of sites (imagine a lattice)
#' @param rich_mean Numeric, mean species richness expected per site.
#' @param rich_sd Numeric, standard deviation of the species richness expected per site
#'
#' @return A data.frame.
#' @export
#'
#' @details Species richness per site is assumed to follow a normal distribution
#' with the provided mean and sd (Negative numbers are truncated). Species are
#' assigned to each site randomly according to its expected distribution, ensuring
#' that common species appear on more sites than rare species. Note that we
#' assume no immigration / emigration.
#'
#' @examples
#' pool <- sp_pool(50)
#' define_sites_years(pool = pool, n_years = 3, n_sites = 10)
define_sites_years <- function(pool, n_years, n_sites,
                             rich_mean = 30, rich_sd = 5){
  #defensive programming here (i.e. check if numeric and range)
  species <- pool[[1]]
  distrib <- pool[[2]]
  #calculate expected richness per site
  richness <- ceiling(rnorm(n_sites, mean = rich_mean, sd = rich_sd))
  #hist(richness) #rpois possible, but a quick visual inspection of data suggest rnorm is good enough.
  #Avoid negative numbers.
  richness <- ifelse(richness < 1, yes = 1, no = richness) #not too elegant.
  #create a vector of species per site over years. We will try to use data.frames to store the outputs

  #igraoh solution which fixes site richness and species occupancy simultaneously:
  library(igraph)
  deg1 <- round(sum(richness) * (distrib/sum(distrib)), digits = 0)
  deg1 <- ifelse(deg1 > n_sites, 10, deg1)
  #sum(deg1) - sum(deg2)
  if(sum(deg1) < sum(deg2)){
    i <- 1
    while(sum(deg1) < sum(deg2)){
      if(deg1[i] < n_sites){deg1[i] <- deg1[i] + 1}
      if(i < length(deg1)){i <- i +1} else{i <- 1}
    }
  }
  if(sum(deg1) > sum(deg2)){
    i <- 1
    while(sum(deg1) < sum(deg2)){
      if(deg1[i] > 1){deg1[i] <- deg1[i] - 1}
      if(i < length(deg1)){i <- i +1} else{i <- 1}
    }
  }
  #sum(deg1) - sum(deg2)
  #remove 0's
  deg1.1 <- deg1[-which(deg1 == 0)]
  deg2 <- richness
  #is_degseq(c(deg1.1, 0 * deg2), c(0 * deg1.1, deg2))
  ntw <- sample_degseq(c(deg1.1, 0 * deg2), c(0 * deg1.1, deg2)) %>%
    set_vertex_attr(name = "type", value = degree(., mode = "out") > 0)
  matrix_ <- as_incidence_matrix(ntw)
  #plot(colSums(matrix_), distrib[-which(deg1 == 0)]) #fair enough
  rownames(matrix_) <- paste0("site_", 1:n_sites)
  colnames(matrix_) <- species[-which(deg1 == 0)]
  data <- melt(matrix_, varnames = c("siteID", "species"))
  data <- subset(data, value > 0)[,-3]
  data
  #And then simply stack as many years as needed
  #We assume no immigration / emigration at this point. i.e. closed populations
  #But species can get extinct over time (see next functions).
  data$year <- 1 #fill first year
  base <- data
  for(i in 1:(n_years-1)){
    newdata <- base
    newdata$year <- i+1
    data <- rbind(data, newdata)
  }
  #head(data)
  data
}


